import numpy as np
import rasterio
from rasterio.warp import reproject, Resampling
import xarray as xr
import xrspatial
import matplotlib.pyplot as plt
import os

# ==========================================
# 1. CONFIGURATION
# ==========================================
INPUT_DEM = 'data/swiss_dem.tif'  # The file you downloaded from OpenTopo
OUTPUT_FILE = 'data/grids/static_terrain.npy'
OUTPUT_META = 'data/grids/grid_metadata.npz' # Save grid coords for later use

# Define the Swiss Alps Bounding Box (WGS84 Lat/Lon)
# Must match the bounds you used to filter stations!
LAT_MIN, LAT_MAX = 45.8, 47.9
LON_MIN, LON_MAX = 5.9, 10.6

# Resolution: ~1km in degrees
# 1 degree lat ~= 111km -> 0.01 deg ~= 1.1km
GRID_STEP = 0.01 

# ==========================================
# 2. DEFINE THE TARGET GRID
# ==========================================
# Create the coordinate arrays for your master grid
target_lats = np.arange(LAT_MIN, LAT_MAX, GRID_STEP)
target_lons = np.arange(LON_MIN, LON_MAX, GRID_STEP)

height = len(target_lats)
width = len(target_lons)

print(f"Target Grid Shape: ({height}, {width}) -> {height*width} pixels")

# Define the affine transform for the target grid
# (This tells rasterio how to map pixels to lat/lon)
# Transform: (pixel_width, 0, min_lon, 0, -pixel_height, max_lat)
# Note: Lat usually goes Top-Down (Max -> Min), so step is negative
target_transform = rasterio.transform.from_bounds(
    west=LON_MIN, south=LAT_MIN, east=LON_MAX, north=LAT_MAX, 
    width=width, height=height
)

# ==========================================
# 3. RESAMPLE DEM TO 1KM GRID
# ==========================================
print("Resampling DEM to 1km grid...")
with rasterio.open(INPUT_DEM) as src:
    # Create an empty array for the destination data
    dem_1km = np.zeros((height, width), dtype=np.float32)
    
    # Reproject/Resample
    reproject(
        source=rasterio.band(src, 1),
        destination=dem_1km,
        src_transform=src.transform,
        src_crs=src.crs,
        dst_transform=target_transform,
        dst_crs=src.crs,
        resampling=Resampling.bilinear # Smooth interpolation
    )

# Handle any potential NoData values (fill with 0 or min)
dem_1km[dem_1km < -100] = 0 

# ==========================================
# 4. CALCULATE SLOPE & ASPECT
# ==========================================
print("Calculating Slope and Aspect...")

# Convert numpy array to xarray for easy processing
# We must specify the chunks to use xrspatial
da_dem = xr.DataArray(dem_1km, coords=[target_lats, target_lons], dims=["lat", "lon"])

# Calculate Slope (Degrees)
# xrspatial handles the complexity of neighbor calculations
slope = xrspatial.slope(da_dem).to_numpy()

# Calculate Aspect (Degrees 0-360)
aspect = xrspatial.aspect(da_dem).to_numpy()

# Handle edges/NaNs generated by calculation (usually borders)
slope = np.nan_to_num(slope, nan=0.0)
aspect = np.nan_to_num(aspect, nan=0.0)

# ==========================================
# 5. NORMALIZATION (CRITICAL FOR CNN)
# ==========================================
# Neural networks hate raw values like 4000 (elevation) vs 0.5 (slope radians)
# We save the mean/std to reverse it later if needed
print("Normalizing features...")

def normalize(arr):
    mean = np.mean(arr)
    std = np.std(arr)
    return (arr - mean) / (std + 1e-6), mean, std

dem_norm, dem_mean, dem_std = normalize(dem_1km)
slope_norm, slope_mean, slope_std = normalize(slope)

# For Aspect, cyclical encoding (Sin/Cos) is better than standard normalization
# 0 degrees and 360 degrees are the same!
aspect_rad = np.deg2rad(aspect)
aspect_sin = np.sin(aspect_rad)
aspect_cos = np.cos(aspect_rad)

# ==========================================
# 6. STACK AND SAVE
# ==========================================
# Final Tensor Shape: (Height, Width, Channels)
# Channels: [Elevation, Slope, Aspect_Sin, Aspect_Cos]
static_tensor = np.stack([dem_norm, slope_norm, aspect_sin, aspect_cos], axis=-1)

os.makedirs('data/grids', exist_ok=True)

# Save the tensor
np.save(OUTPUT_FILE, static_tensor)

# Save metadata (coords and norm stats) for the next scripts
np.savez('data/grids/grid_metadata.npz', 
         lats=target_lats, 
         lons=target_lons,
         dem_stats=(dem_mean, dem_std),
         slope_stats=(slope_mean, slope_std))

print(f"\nSUCCESS! Static tensor saved to: {OUTPUT_FILE}")
print(f"Tensor Shape: {static_tensor.shape}")
print(f"Channels: Elevation(Norm), Slope(Norm), Aspect(Sin), Aspect(Cos)")

# --- Visualization Check ---
plt.figure(figsize=(15, 5))
plt.subplot(1, 3, 1)
plt.title("Elevation (Normalized)")
plt.imshow(static_tensor[:,:,0], origin='lower', cmap='terrain')
plt.subplot(1, 3, 2)
plt.title("Slope (Normalized)")
plt.imshow(static_tensor[:,:,1], origin='lower', cmap='magma')
plt.subplot(1, 3, 3)
plt.title("Aspect (Cos)")
plt.imshow(static_tensor[:,:,3], origin='lower', cmap='twilight')
plt.show()